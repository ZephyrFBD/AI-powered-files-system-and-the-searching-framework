]，b=[0] 
  其命令行是： 
   net.IW{1,1} = [1 2]; 
   net.b{1} = 0; 
  假定模拟的网络有四个无序向量，即Q=4： 
  
 
  这些同步向量可以用一个矩阵来表示： 
  P = [1 2 2 3; 2 1 3 1]; 
  现在我们就可以模拟这个网络了： 
  A = sim(net,P) 
  A = 
  5 4 8 5 
  我们向网络输入一个简单的同步向量矩阵，
得到了一个简单的同步向量输出矩阵。
结果
不论是由一个网络串行输出还是由四个网络并行输出得到的都是一样的。由于输入并无关
联，输入向量的顺序并不重要。 
  动态网络中的异步输入仿真 
  当网络中存在延迟时，
顺序发生的输入向量就要按一定的序列输入网络。
为了演示这种
情况，我们用了一个有延迟的简单网络。 
  
  
  为了建立这个网络我们可以用以下命令： 
  net = newlin([-1 1],1,[0 1]); 
  net.biasConnect = 0; 
  假定权重矩阵为： 
  W=[1，2] 
  命令行为： 
  net.IW{1,1} = [1 2]; 
  假定输入顺序为： 
  p(1)=[1], p(2)=[2],p(3)=[3], p(4)=[4] 
  输入序列可以用一个细胞数组来表示： 
  P = {1 2 3 4}; 
  这样我们就能模拟这个网络了： 
  A = sim(net,P) 
  A = 
  [1] [4] [7] [10] 
  我们输入一个包含输入序列的细胞数组，
网络产生一个包含输出序列的细胞数组。
注意
异步输入中的输入顺序是很重要的。
在这个例子中，
当前输出等于当前输入乘1 加上前一个
输入乘2。如果我们改变输入顺序，那么输出结果也回随之改变。  
  动态网络中的同步输入仿真 
  如果我们在上一个例子中把输入作为同步而不是异步应用，
我们就会得到完全不同的响
应。
（虽然我们不清楚为什么要在动态网络中使用这种方式。
）
这就好象每一个输入都同时加
到一个单独的并行网络中。在前一个例子中，如果我们用一组同步输入，我们有： 
  p1=[1], p2=[2],p3=[3], p4=[4] 
  这可用下列代码创建： 
  P =[1 2 3 4]; 
  模拟这个网络